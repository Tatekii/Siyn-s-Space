

# 原型
JavaScript **既支持面向对象编程，也支持函数式编程**。

JavaScript 采用了一种 **基于原型的面向对象编程（Prototype-based OOP）**，不同于 Java、C++ 这种 **基于类的面向对象编程（Class-based OOP）**。区别于其他面向对象的语言实例中子类复制父类的全部属性。

## 面向对象(OOP)
OOP（Object-Oriented Programming）是一种 **通过对象（Object）组织代码** 的编程范式，强调：
1. **封装（Encapsulation）** → 数据和方法封装在对象内部。
2. **继承（Inheritance）** → 通过继承重用代码，减少重复。
3. **多态（Polymorphism）** → 相同的方法在不同对象上表现不同。


## 继承
**继承（Inheritance）** 允许对象复用其他对象的方法和属性，而不需要重复编写代码。JavaScript 的 OOP 主要依赖 **原型继承（Prototype Inheritance）**，不像 Java 那样基于类（Class），但 ES6+ 引入了 class 语法，使其看起来更像传统 OOP。

### 原型继承
原型对象上定义的方法和属性可以被其子对象继承，js 则使用[[#原型链]]去访问父类的公开属性而不是复制。

### ES5中实现继承
```javascript
// base
function Human(name){
	this.name = name
}

Human.prototype.introduce = function(){
	return this.name
}

```

1. 构造函数继承
	- 只能继承构造函数中的属性

```javascript

function Asian(name){
	Human.call(this,name)
}

```

2. 原型链继承
	- 不能向父类构造函数传参
	- 共享引用类型的属性

```javascript

function Asian(name){

	this.name = name

}

Asian.prototype = new Human()

```

  

3. 1+2组合继承

- 父类构造函数被调用太多次

- 共享引用类型属性

```javascript

function Asian(name){

Human.call(this,name)

}

Asian.prototype = new Human()

```

  

4. 原型式继承

- 适用于不想使用构造函数又想共享数据的情况

- 与原型链模式一样共享引用类型的属性

```javascript

// 其实就是Object.create的实现

function Asian(){

function F(){}

F.prototype = Human

return new F()

}

```

  

5. 寄生继承

- 工厂函数模式

- 难以复用

```javascript

function createAsian(source){

const o = Object.create(source)

o.xxx = xxx //添加自己的属性

return o

}

const s1 = createAsian(Human)

```

6. 寄生组合继承

- 只调用一次父构造函数

- 保持原原型链

```javascript

function Asian(name){

Human.call(this,name)

}

Asian.prototype = Object.create(Human.prototype)

Asian.prototype.constructor = Asian

```

# 原型链
![[Pasted image 20250220114942.png]]
## 构造函数
javascript中只有函数有`prototype`属性，可以访问其原型。


# 原型相关API
## new操作符
- 创建一个空对象
- 将构造函数的prototype指向新对象
- 将构造函数的this指向新对象并执行构造函数
	- 如果执行结构是对象则return这个对象
	- 否则返回这个新对象
```javascript
const isObj = obj => obj !== null && typeof obj === 'object'

function _new(_constructor,...args){

	if (typeof _constructor !== "function") throw new TypeError("constructor must new a function");

	const newObj = Object.create(_constructor_.prototype)
	
	const res = func.call(newObj...args)
	
	return isObj(res) ? res : newObj

}
```

## Object.create
创建新对象并绑定原型
```javascript

Object._create = (proto, propertiesObject) => {
	if (typeof proto !== "function" || typeof proto !== "object") {
		throw new TypeError("instance can only be object or function")
	}

	function F() {}
		F.prototype = proto
		const res = new F()
		if (propertiesObject) {
			Reflect.ownKeys(propertiesObject).forEach((key) => {
				Reflect.defineProperty(res, key, propertiesObject[key])
		})

	}

	return res

}

```
##  instanceof
检测右侧的原型是否在左侧的原型链上游，但它不能检测`null` 和 `undefined`。
```javascript

function _instanceof(instance, constructor) {

	if (typeof constructor !== "object" || constructor === null || constructor === undefined) {
		return false
	}
	
	let L = Reflect.getPrototypeOf(L) // L = L.__proto__
	
	let R = R.prototype

	while (true) {
	
		if (L === null) return false // 原型连到头
		
		if (L === R) return true
		
		L = Reflect.getPrototypeOf(L)
	
	}

}
```
浏览器中的`__proto__`,`getPrototypeOf()`可访问对象的原型。