## ✏️数据模型设计

这是使用 MongoDB 最需要投入精力的地方。虽然 MongoDB 是无模式的，但良好的数据模型设计仍然至关重要。

### **内嵌（Embedding）**
将相关数据存储在同一个文档中（例如，订单文档中内嵌订单项）。适用于一对一或一对少量的关系，可以减少 JOIN 操作，提高读取性能。

```js
// 订单文档中内嵌订单项
{ 
	"_id": ObjectId("60c72b2f9c8f1e001f8e4d2a"), 
	"orderId": "ORD-001", 
	"customerId": "CUST-005", 
	"orderDate": ISODate("2025-06-20T10:00:00Z"),
	"totalAmount": 1225.00, 
	"status": "completed", 
	"items": [ // 内嵌的订单项数组 
		{ 
			"productId": "PROD-A", 
			"productName": "Laptop Pro", 
			"quantity": 1, 
			"price": 1200.00 
		}, 
		{ 
			"productId": "PROD-B", 
			"productName": "Wireless Mouse", 
			"quantity": 1, 
			"price": 25.00 
		} 
	], 
	"shippingAddress": { // 内嵌的地址文档 
		"street": "123 Main St", 
		"city": "Anytown", 
		"zip": "12345" 
	} 
}
```

**优点：**

- **减少查询（JOIN）操作：** 获取一个订单的所有信息只需要一次查询，无需在应用程序层面进行多次查询或模拟 JOIN 操作。这显著提高了读取性能，因为所有相关数据都在一个地方。
    
- **原子性操作：** 在单个文档上的操作是原子性的。这意味着更新一个订单及其内嵌的订单项，要么全部成功，要么全部失败，确保了数据的一致性。
    
- **性能优越：** 数据局域性好，相关数据在磁盘上存储在一起，减少了 I/O 操作。
    
- **简化应用程序代码：** 应用程序处理数据时，可以直接操作一个完整的 JSON 对象，而不需要处理复杂的 JOIN 逻辑。
    

**缺点：**

- **文档大小限制：** MongoDB 单个文档的最大大小限制为 16MB。如果内嵌数组或文档变得非常大，可能会超出这个限制。
    
- **数据冗余：** 如果内嵌的数据（如产品名称 `productName`）在多个地方出现，且需要频繁更新，则会导致数据冗余和更新复杂性。例如，如果 `Laptop Pro` 的名称需要更改，所有包含该商品的订单文档都需要更新。
    
- **更新复杂性：** 当内嵌数组中的元素需要频繁添加、删除或修改时，可能涉及对整个文档的更新，影响性能。
    
- **数据独立访问困难：** 如果你需要单独查询内嵌数组中的某个元素（如“查找所有包含 `PROD-A` 的订单”），可能需要进行全集合扫描或使用聚合框架，效率不如直接引用。

**🔪适用场景：**

- **一对一（One-to-One）关系：** 两个实体之间总是同时被访问，且一个实体完全依赖于另一个实体。
    
- **一对少量（One-to-Few）关系：** 一个实体关联的“子实体”数量有限且可预测，例如一个订单通常只有几十个订单项，一个用户可能有几个地址。
    
- **经常一起查询的数据：** 数据的访问模式是“整体查询”，而不是频繁单独查询内嵌的子数据。
    
- **原子性更新要求高：** 需要确保相关数据作为一个整体进行原子性操作。

### **引用（Referencing）**
通过 `_id` 字段引用另一个集合的文档（类似于关系型数据库的外键）。适用于一对多（多对多）的关系，当被引用的数据需要独立更新或非常大时。

```js
// orders 集合中的订单文档 
{ 
	"_id": ObjectId("60c72b2f9c8f1e001f8e4d2a"), 
	"orderId": "ORD-001", 
	"customerId": ObjectId("60c72b2f9c8f1e001f8e4d2b"), // 引用 customers 集合中的 _id 
	"orderDate": ISODate("2025-06-20T10:00:00Z"),
	"totalAmount": 1225.00, "status": "completed" 
} 
// customers 集合中的客户文档 
{ 
	"_id": ObjectId("60c72b2f9c8f1e001f8e4d2b"),  // <==<
	"name": "Jane Doe", 
	"email": "jane@example.com", 
	"address": { /* ... */ },
}

```
**优点：**

- **避免文档大小限制：** 数据分散在多个文档中，不会受到单个文档 16MB 大小的限制。
    
- **减少数据冗余：** 被引用的数据（如客户信息）只存储一次，减少了冗余，方便数据更新和维护。
    
- **灵活查询：** 可以独立查询和更新被引用的文档。
    
- **处理一对多/多对多关系：** 更容易处理复杂的一对多或多对多关系。
    

**缺点：**

- **需要多次查询（JOIN）操作：** 获取一个订单的所有信息（包括客户详情）通常需要两次查询（先查订单，再根据 `customerId` 查客户），增加了数据库的往返次数（Round Trips）。
    
- **非原子性：** 跨文档的更新不是原子性的，需要应用程序层面的事务管理（MongoDB 4.0 引入了多文档事务，但仍有性能开销）。
    
- **复杂应用程序逻辑：** 应用程序需要管理数据连接和合并的逻辑。
    

**适用场景：**

- **一对多（One-to-Many）和多对多（Many-to-Many）关系：** 当一个实体关联的子实体数量非常多或不可预测时（例如，一个客户可能有很多订单，一个作者可以有很多文章）。
    
- **独立访问数据：** 当被关联的数据需要经常独立地被查询和更新时。
    
- **数据量巨大：** 避免单个文档膨胀超过 16MB 限制。
    
- **降低冗余：** 关联数据更新频繁，需要减少数据冗余。

### 冗余
在实际应用中，你可能需要结合使用内嵌和引用，形成一种**混合模式**。

**示例：** 订单文档中，可以内嵌订单项（数量有限且经常一起访问），但引用客户 ID（客户信息独立且可能很大）：

```js
{
  "orderId": "ORD-001",
  "customerId": ObjectId("60c72b2f9c8f1e001f8e4d2b"), // 引用
  "items": [ // 内嵌
    { "productId": "PROD-A", "quantity": 1, "price": 1200.00 },
    { "productId": "PROD-B", "quantity": 1, "price": 25.00 }
  ],
  "totalAmount": 1225.00
}
```

同时，为了优化某些查询（例如，显示订单列表时需要客户姓名），你可以在订单文档中**冗余**客户的少量关键信息（如 `customerName`），从而避免额外的查询。但这需要应用层确保数据一致性。

```js
{
  "orderId": "ORD-001",
  "customerId": ObjectId("60c72b2f9c8f1e001f8e4d2b"),
  "customerName": "Jane Doe", // 冗余客户姓名
  "items": [ /* ... */ ],
  "totalAmount": 1225.00
}
```
### **预聚合**
**预聚合**是指在数据写入或更新时，或者通过定时任务，**提前计算和存储基于原始数据统计或汇总的结果**。这些结果通常是通过复杂的聚合操作（如计数、求和、平均值等）获得的。

#### 本质
它是[冗余](#冗余)的一种特殊形式，但其冗余的是**计算结果**，而不是简单的原始字段。预聚合的目的是为了**加速复杂的统计查询**。
#### 示例

假设你有一个博客平台，每天有大量的访问日志。你希望能够快速查询每天、每篇文章的访问量，以及每个作者的总阅读量。

**不使用预聚合（每次实时计算）：**

- 查询某篇文章的访问量：可能需要对 `access_logs` 集合进行 `$match` 和 `$count` 操作。
    
- 查询某作者的总阅读量：可能需要对 `access_logs` 集合进行 `$match` 和 `$group` 操作，然后按作者 ID 求和。
    

当 `access_logs` 集合非常庞大时，这些实时计算会非常慢。

**使用预聚合：**

你可以创建额外的集合来存储预聚合的结果：

1. **`daily_article_views` 集合：** 每天统计每篇文章的访问量。
    
    ```json
    // 示例文档
    {
      "date": ISODate("2025-06-23T00:00:00Z"),
      "articleId": "ARTICLE-001",
      "views": 1500,
      "uniqueVisitors": 800
    }
    ```
    
2. **`author_total_views` 集合：** 统计每个作者的总阅读量。
    
    ```json
    // 示例文档
    {
      "authorId": "AUTHOR-XYZ",
      "totalViews": 125000,
      "lastUpdated": ISODate("2025-06-24T02:00:00Z")
    }
    ```
    

这些预聚合的结果可以通过以下方式生成：

- **定时任务：** 每隔一段时间（例如，每天凌晨）运行一个聚合管道，计算前一天的统计数据，并写入 `daily_article_views` 集合。
    
- **触发器/应用逻辑：** 在每次 `access_logs` 插入时，异步地更新 `author_total_views` 集合中的相应计数器。
    

查询时，直接从 `daily_article_views` 或 `author_total_views` 集合读取，速度会非常快。