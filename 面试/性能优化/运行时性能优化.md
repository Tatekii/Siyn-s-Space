## 内存泄漏
1. 全局变量滥用（全局变量无法回收）
2. 定时器和回调
3. 闭包
4. DOM引用
5. 监听器回调
## 性能测试工具
-  Performance面板
	- Timeline
- Memory面板
	- Heap Snapshot

## 代码执行优化
### 变量局部化

缩短访问数据时查找路径,变量存储位置离使用的地方越近越好

```javascript
// bad

var i,str = ''

function packageDom(){

for(i = 0 ; i < 1000 ;i++>){

str += i // 每次循环都要去VO(G)中才能找到str,i

}

return str

}

```

```javascript

// good

function packageDom(){

let str = ''

for(var i = 0 ; i < 1000 ;i++>){

str += i // 不用访问EC(G)

}

return str

}

```

### 减少访问层级

```javascript

// bad

function Person(name){

this.name = 'personnnn'

this.getName = () => {

return this.name

}

}

const p1 = new Person()

p1.getName()

```

```javascript

// good

function Person(name){

this.name = 'personnnn'

}

const p1 = new Person()

p1.name

```

### 缓存数据

缓存需要多次使用的数据

```javascript

// bad

for(let i = 0 ;i < 100000 ;i++){

handle(xxxObj.key1)

}

```

```javascript

// good

const cacheItem = xxxObj.key1

for(let i = 0 ;i < 100000 ;i++){

handle(cacheItem)

}

```

### 减少判断，提前return

```javascript

// bad

const arr = [1,2,3,4,5]

function do(k1,k2){

	if(k1){
	
		if(arr.includes(k1)){
		
			return 'includes'
			
			if(k2>5){
			
				return 666
			
			}
		
		}
	
	}else{
	
	return 'no argument'
	
	}

}

```

```javascript
// good
const arr = [1,2,3,4,5]

function do(k1,k2){

	if(!k1) return 'no argument'

	if(!arr.includes(k1)) return
	
	if(k2>5){
		return 666
	}
}

```

### 减少循环体内操作

```javascript
// bad
for(let i = 0 ; i< arr.length ; i++){
...
}

```

```javascript
// good
const len = arr.length
for(let i = 0 ; i < len ; i++){
...
}
```

```javascript
// better
const len = arr.length
while(len--){
...
}

```

  

### 字面量和构造函数

```javascript
// bad
const o1 = new Object()

o1.a = 666

const str = new String('mmm') // 特别是基本类型，性能损耗很大
```

```javascript
// good
const o1 = {
	a : 666
}

const str = 'mmm' // 字面量调用方法时会被包装为对象

```

  

### 防抖

### 节流