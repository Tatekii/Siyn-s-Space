### 深拷贝
```javascript
const isObject = (obj) => typeof obj === 'object' && obj !== null;

function deepClone(source,cache = new WeakMap()){
	if(!(source!==null && typeof source ==='object') || cache.has(source)){
		return source
	}

	const constructor = source.constructor
	const clone = constructor === Object ? {} : new constructor(source)

	cache.set(source,clone)

	Reflect.ownKeys(source).forEach(k=>{
		clone[k] = deepClone(source[k],cache)
	})
	
	return clone
}

```
### 防抖
不抖了再执行
```javascript
function debounce (callback,wait=300,immediate=true,...args1){
	let timer = null
	
	function _debounced(...args2){
		if(timer){
			clearTimeout(timer)
		}
		const initRun = !timer && immediate

		timer = setTimeout(()=>{
			clearTimeout(timer)
			timer = null
			!immediate && callback.apply(this,[...args1,...args2])
		},wait)
		
		// 立即执行一次
		initRun && callback.apply(this,[...args1,...args2])
	}

	_debounced.clear = function(){
		clearTimeout(timer)
		timer = null
	}

	return _debounced
}
```

### 节流
你再怎么抖也是这个执行节奏
```javascript
function throttle(callback,wait=300,...args1){
	let timer = null
	let prev = 0
	
	function _throttled(...args2){
		const now = +Date.now()
		const _interval = wait - (now - prev)

		if(interval <= 0){
			clearTimeout(timer)
			timer = null
			callback.apply(this,[...args1,...args2])
			prev = now
		}else if(!timer){
			// 还没有定时器但还在尝试触发
			timer = setTimeout(()=>{
				clearTimeout(timer)
				timer = null
				callback.apply(this,[...args1,...args2])
				prev = +Date.now() 
			},wait)
		}
	}

	_throttle.clear = function(){
		clearTimeout(timer)
		timer = null
	}

	return _throttle
}
```
### 并发池
```javascript

async asyncPool (limit,cb,argArray){
	const ret = []
	const executingPool = []

	const len = argArray.length
	for(let i = 0 ; i < len ; i++){
		const p = Promise.resolve(cb(argArray[i]))
		ret.push(p)
		
		const e = p.finally(()=>{
			executingPool.splice(executingPool.indexof(e),1)
		})

		executingPool.push(e)

		if(executingPool.length >= limit){
			await Promise.race(executingPool)
		}	
	}

	return Promise.all(ret)
}


```
### 大数相加
```javascript
const bigAdd  = (num1,num2) =>{

}

const bigFloatAdd = (num1,num2) => {
	// 分割整数小数部分
	const [] = num1.split('.')
	
}


```