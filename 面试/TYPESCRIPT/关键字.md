- `keyof`
	- 访问类型上的公共属性key
- `&`
	- 获取两个类型中的并集，如果在两个类型中有同key但类型不同的属性，该key类型为never
- `extends`
	- 继承接口`interface`,继承多个用逗号隔开
	- 用作条件类型做判断
		- 如果extends前面的类型为泛型，且泛型为联合类型，会分别判断
		```javascript
		type res<T> = T extends 'x' ? 1 : 2

		type res<'x'|'y'> // 1|2

		// 使用[]可以组织分发
		type res<T> = [T] extends 'x' ? 1 : 2

		type res<'x'|'y'> // 2
	   ```
	- 与`infer`出现在协变，逆变场景下
		- 处于协变位置的同一变量的不同类型会联合
		```javascript
		type Foo<T> = T extends { a: infer U; b: infer U } ? U : never;

		type T10 = Foo<{ a: string; b: string }>; // string
		
		type T11 = Foo<{ a: string; b: number }>; // string | number

		```
		- 处于逆变（函数参数）位置的
		```javascript
		type Bar<T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void }

? U

: never;

		type T20 = Bar<{ a: (x: string) => void; b: (x: string) => void }>; // string
		
		type T21 = Bar<{ a: (x: string) => void; b: (x: number) => void }>; // string & number
```
- `infer`
	- 只能在extends中使用
	- 让ts自己推断类型


## `interface`与`type`
在 TypeScript 中，type 和 interface 在定义类型时有一些微妙的区别，尤其是在处理复杂的泛型类型时可能会导致类型实例化过深的警告。

1. **Type vs Interface**:

	• type 是 TypeScript 中的类型别名，它可以用来定义任意的类型。type 可以直接使用泛型参数，并且可以进行交叉类型、联合类型等操作。
	
	• interface 是 TypeScript 中的接口定义，它用来描述对象的结构。interface 不能直接使用泛型参数，而是需要通过接口的方式进行扩展。

2. **Type 的展开特性**:
	
	• type 定义的类型在展开时是逐级展开的，而且 TypeScript 对于递归定义的类型展开时没有明确的深度限制，这可能导致递归层级过深或者无限递归的情况，从而触发警告。
	
	
3. **Interface 的限制**:

	interface 在某些情况下，尤其是通过继承或扩展其他接口时，也会面临类似的问题，但通常情况下不会像 type 那样引发警告，因为接口的展开比较直接和明确。

4. **解决方法**:

	- 如果你遇到 “Type instantiation is excessively deep and possibly infinite” 的警告，可以考虑简化类型定义，尽量避免复杂的递归或泛型定义。

		• 有时候将复杂的类型定义改为使用 interface 可能会有所帮助，因为 interface 的展开方式相对更加直接。

综上所述，警告是因为 type 定义的类型在展开时可能会引发类型实例化过深的问题，特别是在处理复杂的泛型嵌套或递归定义时。选择合适的方式来定义类型可以帮助避免这类问题。

