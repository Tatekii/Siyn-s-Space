# 原型
JavaScript **既支持面向对象编程，也支持函数式编程**。

JavaScript 采用了一种 **基于原型的面向对象编程（Prototype-based OOP）**，不同于 Java、C++ 这种 **基于类的面向对象编程（Class-based OOP）**。

## 面向对象(OOP)
OOP（Object-Oriented Programming）是一种 **通过对象（Object）组织代码** 的编程范式，强调：
1. **封装（Encapsulation）** → 数据和方法封装在对象内部。
2. **继承（Inheritance）** → 通过继承重用代码，减少重复。
3. **多态（Polymorphism）** → 相同的方法在不同对象上表现不同。

# 原型链
![[Pasted image 20250220114942.png]]
在 JavaScript 中，万物皆为对象，几乎所有对象的都是 `Object` 的实例(除了`Object.create(null)`)，一个典型的对象从 `Object.prototype` 继承属性（包括方法）。

每个对象有自己的原型对象，原型对象也有自己的原型对象，一直到Object.prototype的原型`null`,到达原型链的终点。

原型链上的行为：
当试图访问对象的属性时，不仅在该对象上查找属性，还会在该对象的原型上查找属性，以及原型的原型，依此类推，直到找到一个名字匹配的属性或到达原型链的末尾。
```javascript
Object.prototype.__proto__ = null

```

示例：
```javascript
function doSomething() {}
doSomething.prototype.foo = "bar"; // 向原型添加一个属性
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value"; // 向对象添加一个属性
console.log(doSomeInstancing);
// log
{
  prop: "some value",
  [[Prototype]]: { // --> doSomething.prototype
    foo: "bar",
    constructor: ƒ doSomething(),
    [[Prototype]]: {  // -> Object.prototype
      constructor: ƒ Object(),
      hasOwnProperty: ƒ hasOwnProperty(),
      isPrototypeOf: ƒ isPrototypeOf(),
      propertyIsEnumerable: ƒ propertyIsEnumerable(),
      toLocaleString: ƒ toLocaleString(),
      toString: ƒ toString(),
      valueOf: ƒ valueOf()
      // [[Prototype]] : null <-- END
    }
  }
}
```


## 构造函数
可以被`new`调用的函数。
`new Constructor(...)`
构造函数创建的实例会自动链接上构造函数的原型(Constructor.prototype)

### 类class
类是构造函数的语法糖。
```javascript
// 构造函数
function Box(value) {
  this.value = value;
}

// 使用 Box() 构造函数创建的所有盒子都将具有的属性
Box.prototype.getValue = function () {
  return this.value;
};



// class
class Box {
  constructor(value) {
    this.value = value;
  }

  // 在 Box.prototype 上创建方法
  getValue() {
    return this.value;
  }
}
```


# 继承
**继承（Inheritance）** 允许对象复用其他对象的方法和属性，而不需要重复编写代码。JavaScript 的 OOP 主要依赖 **原型继承（Prototype Inheritance）**，不像 Java 那样基于类（Class），但 ES6+ 引入了 class 语法，使其看起来更像传统 OOP。

## 六大基本原则：
- `Single Responsibility Principle：单一职责原则`
	一个类应该只有一个发生变化的原因，只负责一项职责
- `Open Closed Principle：开闭原则`
	对修改封闭，对拓展开放
- `Liskov Substitution Principle：里氏替换原则`
	子类能完全替代父类
- `Law of Demeter：迪米特法则`
	功能模块之间尽量减少相互作用，保持相互独立
- `Interface Segregation Principle：接口隔离原则`
	用多个借口将功能解耦
- `Dependence Inversion Principle：依赖倒置原则`
	高层模块不应该依赖低层模块，二者都应该依赖其抽象，对抽象接口进行编程

## 原型继承
原型对象上定义的方法和属性可以被其子对象继承，js 则使用[[#原型链]]去访问父类的公开属性而不是复制。

### ES5中实现继承
```javascript
// base
function Human(name){
	this.name = name
}

Human.prototype.introduce = function(){
	return this.name
}

```

2. 构造函数继承
	- 只能继承构造函数中的属性

	```javascript

	function Asian(name){
		Human.call(this,name)
	}
	
	```

3. 原型链继承
	- 不能向父类构造函数传参
	- 子类共享父类原型中引用类型的属性

	```javascript

	function Asian(name){
		this.name = name
	}
	
	Asian.prototype = new Human()
	
	```
4. 组合继承
	- 父类构造函数被调用太多次
	-  子类共享父类原型中引用类型的属性

	```javascript

	function Asian(name){
		Human.call(this,name)
	}
	
	Asian.prototype = new Human()
	
	```
5. 原型式继承
	- 适用于不想使用构造函数又想共享数据的情况
	- 与原型链模式一样共享引用类型的属性

	```javascript
	
	// 其实就是Object.create的实现
	
	function Asian(){
	
		function F(){}
	
		F.prototype = Human
	
		return new F()
	}
	
	```

6. 寄生继承
	- 工厂函数模式
	- 难以复用

	```javascript
	
	function createAsian(source){
	
		const o = Object.create(source)
		
		return o
		
	}
	
	const s1 = createAsian(Human)
	
	```

7. 寄生组合继承
	- 只调用一次父构造函数
	- 保持原原型链

	```javascript
	
	function Asian(name){
	
		Human.call(this,name)
	
	}
	
	Asian.prototype = Object.create(Human.prototype)
	
	Asian.prototype.constructor = Asian
	
	```


# 原型相关API
## `new`操作符
- 创建一个空对象
- 将构造函数的prototype指向新对象
- 将构造函数的this指向新对象并执行构造函数
	- 如果执行结构是对象则return这个对象
	- 否则返回这个新对象
```javascript
const isObj = obj => obj !== null && typeof obj === 'object'

function _new(_constructor,...args){

	if (typeof _constructor !== "function") throw new TypeError("constructor must new a function");

	const newObj = Object.create(_constructor_.prototype)
	
	const res = func.call(newObj...args)
	
	return isObj(res) ? res : newObj

}
```

## Object.create
创建新对象并绑定原型
```javascript

Object._create = (Prototype, propertiesObject) => {
	if (typeof Prototype !== "object") {
		throw new TypeError(" Object prototype may only be an Object or null")
	}

	function F() {}
		F.prototype = proto
		const res = new F()
		if (propertiesObject) {
			Reflect.ownKeys(propertiesObject).forEach((key) => {
				Reflect.defineProperty(res, key, propertiesObject[key])
		})

	}

	return res

}

```
##  instanceof
检测右侧的原型是否在左侧的原型链上游，但它不能检测`null` 和 `undefined`。
```javascript

function _instanceof(instance, constructor) {

	if (typeof constructor !== "object" || constructor === null || constructor === undefined) {
		return false
	}
	
	let L = Reflect.getPrototypeOf(L) // L = L.__proto__
	
	let R = R.prototype

	while (true) {
	
		if (L === null) return false // 原型连到头
		
		if (L === R) return true
		
		L = Reflect.getPrototypeOf(L)
	
	}

}
```
浏览器中的`__proto__`,`getPrototypeOf()`可访问对象的原型。