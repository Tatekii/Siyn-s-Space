
## 页面进程
浏览器每一个标签页一个进程，每个进程中除了执行js的线程还有负责渲染，网络请求等线程。

## JS 的单线程
JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程,保证执行任务的有序并避开复杂的同步问题。
 
## 浏览器中的事件循环
[https://html.spec.whatwg.org/multipage/webappapis.html#event-loops](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)
![[Pasted image 20250218095926.png]]
浏览器是多线程的，js是单线程的，JavaScript 有一个基于**事件循环**的运行时模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。通过讲监视调用栈`Call Queue`和任务队列`Task Queue`，在调用栈为空时从任务队列读取任务进入执行栈执行。

### 调用栈
栈结构，后进先出，存储程序执行过程 中创建的所有执行上下文`Excution Context`。在代码执行的时候，通过将不同函数的执行上下文压入执行栈，上下文执行结束后按顺序弹出中来保证代码的有序执行。

### 任务队列
任务队列`Task Queue`⚠️并不是队列结构，而是集合set，存储待处理的事件，这些事件可能包括用户交互（点击滚动），网络请求，定时器等。事件循环模型从任务队列中抓去第一个可执行的任务而不是队头。
- 同种任务会遵循**FIFO (First In, First Out)**。
- 不同种任务：宏/微任务，UI交互事件，定时器，I/O回调会有不同的执行优先级。
### 宏任务队列
**宿主**环境下发任务
- 整体script（相对的）
- setTimeout
- setInterval
- setImmediate
- I/O
- UI rendering
### 微任务队列
js引擎自己创建的任务
- Promise回调（then, catch, finally...）
- MutationObserver
- queueMicrotask（异步回调，宏任务前执行）
- ⚠️process.next（Node环境中）

### 执行顺序
1. 程序执行，按顺序将执行上下午压入执行栈中
2. 执行过程中的异步任务会讲他们的回调函数分别放入宏任务/微任务队列
3. 执行栈为空后，读取微任务队列执行
	1. 微任务队列执行过程中产生的微任务会推入本轮微任务队列
	2. 微任务队列执行过程中产生的宏任务会加入下一轮事件循环
	3. ⭐️async function
		1. await 关键字会将函数内的剩余代码规划为微任务
	4. ⭐️Promise.then.then
		1. 链式调用的Promise回调必须等待当前微任务队列清空（注意面试题中的then深度是否相同）
		2. 第二个then需等待当前微任务执行完，而第一个then直接推进当前微任务队列
4. 浏览器进行渲染
5. 执行栈为空后，读取宏任务队列执行
	1. 如果宏任务执行过程中创建了新的微任务，会在下个宏任务之前执行
	2. 如果宏任务执行过程中创建了新的宏任务，会加入下一轮事件循环
6. 下一轮循环

#### test
1. 宏任务派生
	```javascript
console.log("Start");

setTimeout(() => {
    console.log("Macrotask A");
    Promise.resolve().then(() => {
        console.log("Microtask 1");
        setTimeout(() => console.log("Macrotask A-1"), 0);
    });
}, 0);

setTimeout(() => {
    console.log("Macrotask B");
}, 0);

console.log("End");
```
2. 微任务派生
	```javascript
console.log("Start");


Promise.resolve().then(() => {
	console.log("Microtask A start");
	Promise.resolve().then(() => {
		console.log("Microtask A-1");
	})
	setTimeout(() => console.log("Macrotask A-1"), 0);
	Promise.resolve().then(() => {
		console.log("Microtask A-2");
	})
	console.log("Microtask A end");
});

Promise.resolve().then(() => {
	console.log("Microtask B");
	Promise.resolve().then(() => {
		console.log("Microtask B-1");
	})
});

console.log("End");

/** 
start
end
Microtask A start
Microtask A end
Microtask B
Microtask A-1
Microtask A-2
Microtask B-1
Macrotask A-1
*/



```
3. Promise 链式调用
	```javascript
/// 1
console.log("Start");

Promise.resolve()
  .then(() => {
    console.log("First then");
    Promise.resolve().then(() => {
      console.log("Inner then");
    });
  })

  .then(() => {
    console.log("Second then");
  });

console.log("End");

/// 2
new Promise((resolve, reject) => {
    	console.log("promise1"); // 1
    	resolve();
    })
    	.then(() => {
    		console.log("then11"); // 2
    		new Promise((resolve, reject) => {
    			console.log("promise2"); // 3
    			resolve();
    		})
    			.then(() => {
    				console.log("then21"); // 4
    			})
    			.then(() => {
    				console.log("then23"); // 6
    			});
    	})
    	.then(() => {
    		console.log("then12"); // 5
    	});

/** 微任务队列
then11 ,  new Promise , then12
new Promise , then12
then21 , then12 ,then23
*/


    new Promise((resolve, reject) => {
    	console.log("promise");
    	resolve();
    })
    	.then(() => {
    		console.log("thenA");
    		new Promise((resolve, reject) => {
    			console.log("promiseA-1");
    			resolve();
    		})
    			.then(() => {
    				console.log("thenA-1");
    			})
    			.then(() => {
    				console.log("thenA-1-1");
    			});
    	})
    	.then(() => {
    		console.log("thenB");
            new Promise((resolve, reject) => {
    			console.log("promiseB-1");
    			resolve();
    		})
    			.then(() => {
    				console.log("thenB-1");
    			})
    			.then(() => {
    				console.log("thenB-1-1");
    			});
    	});
/** 微任务队列
thenA , new PromiseA-1 , thenB ,new PromiseB-1
new PromiseA-1 , thenB ,new PromiseB-1
thenA-1 , thenB ,new PromiseB-1 , thenA-1-1
thenA-1-1 , thenB-1, thenB-1-1

*/
```
4. async 
	```javascript
    async function async1() {
    	console.log("async1 start");
    	await async2();
    	console.log("async1 end"); // (⭐️Microtask - 1)
    }

    async function async2() {
    	console.log("async2");
    }

    console.log("script start");

    async1();

    new Promise(function (resolve) {
    	console.log("promise1");
    	resolve();
    }).then(function () {
    	console.log("promise2");// (⭐️Microtask - 2)
    });
    console.log("script end");

/** execution
script start
async1 start
async2
promise1
script end
async1 end
promise2
*/


async function async1() {
	console.log("async1 start"); 
	await async2();
	console.log("async1 end"); // (⭐️Microtask - 1)
}

async function async2() {
	console.log("async2"); 
}

console.log("script start"); 

setTimeout(function () {
	console.log("settimeout");
});

async1();

new Promise(function (resolve) {
	console.log("promise1"); 
	resolve();
}).then(function () {
	console.log("promise2"); // (⭐️Microtask - 2)
});

console.log("script end"); 


/** 
script start
async1 start
async2
promise1
script end
async1 end
promise2
settimeout
*/
```