```solidity
function <function name>([parameter types[, ...]]) {internal|external|public|private} [pure|view|payable] [virtual|override] [<modifiers>]
[returns (<return types>)]{ <function body> }
```

## 函数权限/功能
- `payable`（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入 ETH。
	- 只有[`external`](变量可见性.md#`external`)和[`public`](变量可见性.md#`public`)函数支持`payable`修饰（不然呢）
- `pure`既不能读取也不能写入链上的状态变量。
- `view` 能读取但也不能写入状态变量。
⚠️注意
合约中非 `pure`/`view` 函数调用 `pure`/`view` 函数时需要付[Gas](Gas.md)

## 重载
- `virtual`用在父合约上，标识的方法可以被子合约重写。
- `override`用在自合约上，表名方法重写了父合约的方法。	
	- 覆盖函数必须使用与被覆盖函数相同的函数名称、参数列表和返回类型

## 修饰器（装饰器）
- `<modifiers>`
- 自定义的修饰器，可以有0个或多个修饰器
- `_;`表示被修饰的函数
```sol
modifier lock() {
	require(locked == 0);
	locked = 1;
	_;
	locked = 0;
}
```
- 当函数有多个修饰符时，它们按照它们在函数声明中出现的顺序应用。 每个修饰符必须在函数执行之前成功验证，从而创建一系列条件来共同确定函数是否可以继续。
## 返回 
- `[returns ()]`：函数返回的变量类型和名称。
