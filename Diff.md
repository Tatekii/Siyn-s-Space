# **React Fiber Diff 的时间复杂度分析**
在 React 16+ 的 Fiber 架构中，**Diff 过程**主要发生在 **新旧 Fiber 树的对比**，而新旧节点的核心对比逻辑依赖于 **链表遍历** 和 **Keyed Diff**。

## **1. 直接对比（O(N))**
在最理想的情况下，如果 **新旧节点的顺序没有变化**，React 只需要**逐个遍历**并比较节点是否相同。这种情况下，时间复杂度是：`O(N)`
其中 **N** 是子节点的数量。

**示例：**
```js
// 旧 Virtual DOM
<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>

// 新 Virtual DOM（顺序不变）
<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>
```

**计算过程：**
React 遍历 **每个子节点** 并比较 type 和 props，总共执行 **N 次** 对比操作。

## 2. 无 **key 情况（O(N²))**
如果 **节点顺序发生变化**，但**没有 key**，React 仍然采用**逐个遍历**的方式去寻找匹配的旧节点，这会导致**嵌套循环**：`O(N^2)`

**示例：**

```js
// 旧 Virtual DOM
<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>

// 新 Virtual DOM（B 和 A 互换）
<ul>
  <li>B</li>
  <li>A</li>
  <li>C</li>
</ul>
```

**计算过程：**

1. **第 1 次循环（找 B）**
	- 旧 A 不匹配 → 继续查找
	- 旧 B 匹配 → 交换 A 和 B

2. **第 2 次循环（找 A）**
	- 旧 B 不匹配 → 继续查找
	- 旧 A 匹配 → 交换 A 和 B

3. **C 匹配**

由于 React **在每个位置都要检查所有可能的旧节点**，导致 **N 个节点，每个节点都可能触发一个 O(N) 级别的匹配搜索**，最终复杂度：`O(N^2)`

## 