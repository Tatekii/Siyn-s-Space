## Nodeçš„äº‹ä»¶å¾ªç¯
### libuv
>nodeçš„äº‹ä»¶å¾ªç¯æ¨¡å‹ç”±[libuv](https://libuv.org/)å®ç°ã€‚
>libuv is a multi-platform support library with a focus on asynchronous I/O.
![](../../assets/Pasted%20image%2020250218125318.png)

### äº‹ä»¶å¾ªç¯
[https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#event-loop-explained](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#event-loop-explained)
![](../../assets/Pasted%20image%2020250218125604.png)
å„é˜¶æ®µè¯´æ˜
- **timers**: æ‰§è¡Œå®šæ—¶å™¨å›è°ƒ
	- this phase executes callbacks scheduled byÂ `setTimeout()`Â andÂ `setInterval()`.
- **pending callbacks**: æ‰§è¡Œä¸Šä¸€è½®å¾ªç¯ä¸­å»¶è¿Ÿæ‰§è¡Œçš„I/O
	- executes I/O callbacks deferred to the next loop iteration.
	- æ¯”å¦‚[[TCP]]è¿æ¥çš„äº‹ä»¶
- **idle, prepare**: ç³»ç»Ÿå†…éƒ¨è°ƒç”¨
	- only used internally.
- **poll**: è½®è¯¢ï¼Œæ£€ç´¢æ–°çš„I/Oäº‹ä»¶ï¼Œæ‰§è¡ŒI/Oå›è°ƒï¼Œé™¤äº†å®šæ—¶å™¨,setImmediateå›è°ƒå’Œå…³é—­å›è°ƒ
	- retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, andÂ `setImmediate()`); node will block here when appropriate.
- **check**:Â setImmediateå›è°ƒæ‰§è¡Œ
	- `setImmediate()`Â callbacks are invoked here.
- **close callbacks**: å…³é—­å›è°ƒï¼Œå„ç§on('close')
	- some close callbacks, e.g.Â `socket.on('close', ...)`.

### ä»»åŠ¡é˜Ÿåˆ—
nodeçš„äº‹ä»¶å¾ªç¯ï¼Œå¯¹äºå¾®ä»»åŠ¡ç»†åˆ†ä¸ºä¸¤ç§ã€‚
- nextTickQueue
	- å•ç‹¬ç»™process.nextä½¿ç”¨
	- ä¸­æ–­nodeæ‰§è¡Œé˜¶æ®µçš„ç»§ç»­ï¼Œé˜»æ­¢è¿›å…¥`poll`é˜¶æ®µ
		- all callbacks passed toÂ `process.nextTick()`Â will be resolved before the event loop continues.
- other queue
	- å…¶ä½™å¾®ä»»åŠ¡
#### `rpocess.nexttick`
ä¸­æ–­nodeæ‰§è¡Œé˜¶æ®µçš„ç»§ç»­ï¼Œåœ¨æ‰§è¡Œå®Œå®ä»»åŠ¡é˜Ÿåˆ—åé˜»æ­¢è¿›å…¥`poll`é˜¶æ®µã€‚
```javascript
const server = net.createServer(() => {}).listen(8080);
// listen()å‡½æ•°å·²ç»è¢«æ‰§è¡Œï¼Œä¸‹é¢çš„äº‹ä»¶ç»‘å®šåº”è¯¥æ˜¯å¤±æ•ˆçš„
server.on('listening', () => {});
// ä½†æ˜¯listeningäº‹ä»¶æ˜¯ç”¨nextTick()åŒ…è£¹ï¼Œä»è€Œåœ¨æ•´æ®µä»£ç ä»£ç æ‰§è¡Œ åè¿è¡Œ
```
âš ï¸tickæŒ‡çš„æ˜¯ä¸€æ¬¡äº‹ä»¶å‘¨æœŸï¼Œè€ŒnextTickçš„æ‰§è¡Œæ—¶æœºå¹¶æ²¡æœ‰åœ¨ä¸‹ä¸€ä¸ª`tick`ä¹‹å‰ï¼Œå…¶åè¿˜æœ‰ä¸€`check`é˜¶æ®µã€‚è¿™ç©æ„å†å²åŒ…è¢±å·²ç»æ”¹ä¸äº†äº†ã€‚

#### `setImmediate`
åœ¨`check`é˜¶æ®µï¼ˆ`poll`å¾®ä»»åŠ¡é˜Ÿåˆ—æ‰§è¡Œå®Œåï¼‰æ‰§è¡Œã€‚
âš ï¸çœŸæ­£çš„next tickğŸ˜‚

#### TEST
```javascript
async function async1() {
	console.log("async1 start"); 
	await async2(); // async2ä¼šåŒæ­¥æ‰§è¡Œï¼Œä½†awaitä¸‹é¢çš„ä»£ç ä¼šåŠ å…¥å¾®ä»»åŠ¡é˜Ÿåˆ—ä»¥ç­‰å¾…awaitå³ä¾§ä»£ç å¾—å‡ºstatus
	console.log("async1 end"); // (microtask)
}

async function async2() {
	console.log("async2"); 
}

console.log("script start"); 

setTimeout(function () {
	console.log("settimeout0");
});

setTimeout(function () {
	console.log("settimeout300");
},300);

setImmediate(function () {
	console.log("setImmediate");
});

process.nextTick(() => {
	console.log('nextTick1');

	process.nextTick(() => {
	console.log('nextTick1');
	});
});

async1();

process.nextTick(() => console.log('nextTick2'));

new Promise(function (resolve) {
	console.log("promise1"); 
	resolve();
	console.log('promise2')
}).then(function () {
	console.log("promise3"); // (microtask)
});

console.log("script end"); 
/**
// sync
script start
async1 start
async2
promise1
promise2
script end
// nextTick
nextTick1
nextTick2
nextTick1
// å¾®ä»»åŠ¡
async1 end
promise3
// timer
settimeout0
// check
setImmediate
// timer after 300ms
settimeout300
*/

```

```javascript
setTimeout(()=>{
	console.log('timeout')
},0)
setImmediate(()=>{
	console.log('immediate')
})
	
	// ä¸ä¸€å®šæŒ‰ç…§timeout => immediate
	// ç”±äºv8çš„setTimeoutè®¡ç®—å¯èƒ½ä¼šè¶…è¿‡libuvçš„å¯åŠ¨æ—¶é—´ï¼Œå¯¼è‡´timeoutçš„å›è°ƒåªèƒ½åœ¨libuvå¯åŠ¨ååŠ å…¥ï¼Œåœ¨ä¸‹ä¸€è½®å¾ªç¯æ‰§è¡Œ
	// timer --|-----|
	// poll ---|libuv|
	// check --|-----|
```